
\chapter{Translating SociaLite programs to Pregel}\label{r:s2p}


\begin{verbatim}

SociaLite to Giraph compilation plan

Input: AST from parser
Goal output: Giraph program

AST is in the form:
Program (
	[Declarations]
	[Rules]
)

Put all declarations in Env. There are 3 kinds of declarations:
constant value
sharded table
non-sharded table
Sharded tables define ranges of vertices on which they will be stored. -> compute number of vertices (N).
Non-sharded tables will be stored on Master node.
Verify semantic validity of each rule according to Enviroment.
Build rules graph.
*Divide rules into strata based on negations.
Find recursive cycles and for each rule identify in which recursive cycles it is.
*Check that each recursive cycle is within one strata (error otherwise)
add artificial rules and tables so that all computation is based on local data, and the only communication with other vertices is by sending new results to them
We require that each table appears only once on the left side (but can have many alternative conditions sets on the right side). Compute method in vertex v will be waiting until it receives some new_data to be put in dest_table in its shard.
For each regular rule:
	result[u](args) :- 	   conditions_set_1;
   conditions_set_2;
   ...
   conditions_set_n.
emit:
if new_data not present in dest_table:
save dest_table(new_data)
	for each conditions_set:
if dest_table in conditions_set:
			try find new results from this rule using new_data
			if found, send them to destination vertex u
For each aggregation in recursive cycle:
		result[u](args, AGREGATE(arg)) :- 	conditions_set_1;
   			conditions_set_2
   			...
   			conditions_set_n.
check whether it is a meet operation and monotonic. If yes, then emit code similar to the one above, but instead of checking if data is present in dest_table, apply aggregation upon receiving new_data, before saving it.
If not, then additionally before looking for new results send out messages to invalidate previously generated results
For each global (non-sharded) aggregation, generate a Giraph aggregator for it.



Basic idea: one vertex for each value of (some) variables in statements.
Vertex remembers all statements which have this value on either variable.

Example:
Let us have the following statements:
EDGE(1, 2, 10000), EDGE(2, 3, 5000), EDGE(1, 3, 20000),
PATH(1, 2, 10000), PATH(2, 3, 5000), PATH(1, 3, 15000)
We would then have vertices 1, 2, 3:
1 – EDGE(1, 2, 10000), EDGE(1, 3, 20000), PATH(1, 2, 10000), PATH(1, 3, 15000)
2 – EDGE(1, 2, 10000), EDGE(2, 3, 5000), PATH(1, 2, 10000), PATH(2, 3, 20000)
3 – EDGE(1, 3, 20000), EDGE(2, 3, 5000), PATH(1, 3, 15000), PATH(2, 3, 20000)
What values need to have their vertices depends on the program, but we probably don't need vertices for values 5000, 10000, 15000, 20000. We surely need vertices for values by which we join. SociaLite declariations may help with this.

DOUBLE_EDGE(p, r) :- EDGE(p, q), EDGE(q, r)


Datalog/Socialite
Pregel idea
Shortest Paths, Datalog


PATH(t, d) :- EDGE(1, t, d).


PATH(t, d) :- PATH(s, d1), EDGE(s, t, d2), d = d1 + d2.



MINPATH(t, $MIN(d)) :- PATH(t, d). 




One vertex for each t value. Vertex initially has all EDGE(_, t, _) and EDGE(_, t, _) values.


Vertex initializes its PATH(t, d) value according to the rule.



Repeat until no change: each vertex tries to match the rule as s vertex, and sends out new PATH values to t vertices. Each time vertex updates its PATH value it revaluates the rule and sends out new PATHs to neighbors.

Each vertex computes min of its PATH values and stores its MINPATH.
Shortest Paths, SociaLite

EDGE (int src: 0..10000, (int sink, int len)).
PATH (int sink: 0..10000, int dist).



PATH(t, $MIN(d)) :- EDGE(1, t, d);
                        
                  :- PATH(s, d1), EDGE(s, t, d2), d = d1 + d2. 


	 	 	

One vertex for each t value. Vertex initially has all EDGE(_, t, _) and EDGE(_, t, _) values.


Vertex initializes its PATH(t, d) value according to the rule.

Repeat until no change: each vertex tries to match the rule as s vertex, and sends out new PATH values to t vertices. Each time vertex receives a message it tries to update its minimum of PATH value. After each such update, it reevaluates the rule and sends out new PATHs to neighbors.

Note 1: this is basically the standard version of Shortest Paths in Pregel. Different than Datalog thanks to recursive aggregation.
Connected Components, SociaLite

int N = 1768195.
EDGE (int src: 0..N, (int sink)).
NODES (int n: 0..N).
COMP (int n: 0..N, int root).
COMPIDS (int id).
COMPCOUNT (int cnt).

COMP(n, $MIN(i)) 	:- NODES(n), i = n;

		:- COMP(p, i), EDGE(p, n).


COMPIDS(id) :- COMP(_, id).

COMPCOUNT($SUM(1)) : - COMPIDS(id). 






Set COMP(n, n)

Repeat until no change: always after updating the minimum, vertex p sends new values to all matching vertices n. Upon receiving messages, try to update the minimum.

Each vertex rewrites the value.

Compute SUM using Pregel aggregation mechanism.
Triangles, SociaLite

int N = 1768195.
EDGE (int src: 0..N, (int sink)) orderby sink .
TRIANGLE (int x, int y, int z).
TOTAL (int cnt).

TRIANGLE(x, y, z) : - EDGE(x, y), x < y, EDGE(y, z), y < z, EDGE(x, z).



TOTAL($SUM(1)) :- TRIANGLE(x, y, z). 


	 	 	




Two Pregel supersteps: 1) Intermediate join of EDGE(x, y), x < y, EDGE(y, z), by vertex y
2) Join of EDGE_TMP(x, z), y < z, EDGE(x, z) by vertex x (or z)

Compute SUM using Pregel aggregation mechanism.




\end{verbatim}




